#!/usr/bin/env python3
"""Manage embedded Game Boy ROMs bundled with the firmware image."""

from __future__ import annotations

import argparse
import datetime as _dt
import json
import re
import shutil
import sys
from pathlib import Path
from typing import Iterable

REPO_ROOT = Path(__file__).resolve().parent.parent
MANIFEST_PATH = REPO_ROOT / "embedded_roms.json"
DATA_DIR = REPO_ROOT / "embedded_roms"
OUTPUT_CPP = REPO_ROOT / "embedded_rom.cpp"

CHUNK_SIZE = 16


def _hex_lines(blob: bytes, chunk_size: int = CHUNK_SIZE) -> list[str]:
    lines: list[str] = []
    for i in range(0, len(blob), chunk_size):
        chunk = blob[i : i + chunk_size]
        values = ", ".join(f"0x{byte:02X}" for byte in chunk)
        lines.append(f"    {values}")
    if lines:
        lines[-1] = lines[-1].rstrip()
    return lines


def _load_manifest() -> list[dict]:
    if not MANIFEST_PATH.exists():
        return []
    data = json.loads(MANIFEST_PATH.read_text(encoding="utf-8"))
    entries = data.get("entries", [])
    if not isinstance(entries, list):
        raise ValueError("Manifest is corrupt: 'entries' must be a list")
    return entries


def _save_manifest(entries: Iterable[dict]) -> None:
    payload = {
        "version": 1,
        "updated": _dt.datetime.utcnow().isoformat() + "Z",
        "entries": list(entries),
    }
    MANIFEST_PATH.write_text(json.dumps(payload, indent=2, sort_keys=True) + "\n", encoding="utf-8")


def _slugify(label: str) -> str:
    slug = re.sub(r"[^a-z0-9]+", "-", label.lower()).strip("-")
    if not slug:
        slug = "rom"
    return slug


def _ensure_unique_slug(entries: list[dict], desired: str) -> str:
    slug = desired
    suffix = 1
    existing = {entry["id"] for entry in entries}
    while slug in existing:
        suffix += 1
        slug = f"{desired}-{suffix}"
    return slug


def _copy_rom(source: Path, dest: Path) -> None:
    dest.parent.mkdir(parents=True, exist_ok=True)
    shutil.copy2(source, dest)


def _generate_cpp(entries: list[dict]) -> None:
    timestamp = _dt.datetime.utcnow().isoformat() + "Z"

    lines: list[str] = [
        "#include <cstddef>",
        "#include <cstdint>",
        "#include <cstring>",
        "#include <pgmspace.h>",
        "",
        "#include \"embedded_rom.h\"",
        "",
        "// Auto-generated by scripts/embed_rom.py on {}".format(timestamp),
        f"// Entries: {len(entries)}",
        "",
        "namespace {",
        "",
    ]

    rom_defs: list[str] = []
    entry_refs: list[str] = []

    for index, entry in enumerate(entries):
        slug = entry["id"]
        name = entry.get("name") or slug
        file_name = entry["file"]
        rom_path = DATA_DIR / file_name
        if not rom_path.exists():
            raise FileNotFoundError(f"Embedded ROM payload missing: {rom_path}")

        rom_data = rom_path.read_bytes()
        if not rom_data:
            raise ValueError(f"Embedded ROM '{slug}' is empty: {rom_path}")

        original_size = len(rom_data)
        padding = (4 - (original_size % 4)) % 4
        if padding:
            rom_data += bytes([0xFF] * padding)

        array_name = f"kRom{index}Data"
        entry_name = f"kRom{index}Entry"

        lines.append(
            f"// ROM {index}: id='{slug}', name='{name}', source='{file_name}', size={original_size} bytes"
        )
        lines.append(f"alignas(4) const uint8_t {array_name}[] PROGMEM = {{")
        lines.append(",\n".join(_hex_lines(rom_data)) if rom_data else "    0xFF")
        lines.append("};")
        lines.append("")

        lines.append(f"static const EmbeddedRomEntry {entry_name} = {{")
        lines.append(f"    {json.dumps(slug)},")
        lines.append(f"    {json.dumps(name)},")
        lines.append(f"    {array_name},")
        lines.append(f"    {original_size}u,")
        lines.append(f"    {str(bool(entry.get('autoboot'))).lower()}")
        lines.append("};")
        lines.append("")

        entry_refs.append(f"    &{entry_name}")
    lines.append("} // namespace")
    lines.append("")

    count = len(entries)
    if count:
        lines.append(f"const size_t kEmbeddedRomCount = {count}u;")
        lines.append(f"const EmbeddedRomEntry *const kEmbeddedRoms[{count}] = {{")
        lines.append(",\n".join(entry_refs))
        lines.append("};")
    else:
        lines.append("const size_t kEmbeddedRomCount = 0u;")
        lines.append("const EmbeddedRomEntry *const kEmbeddedRoms[1] = { nullptr };")
    lines.append("")

    lines.append("const EmbeddedRomEntry *embedded_rom_get_autoboot() {")
    if count:
        lines.append("  for(size_t i = 0; i < kEmbeddedRomCount; ++i) {")
        lines.append("    const EmbeddedRomEntry *entry = kEmbeddedRoms[i];")
        lines.append("    if(entry != nullptr && entry->autoboot) {")
        lines.append("      return entry;")
        lines.append("    }")
        lines.append("  }")
        lines.append("  return nullptr;")
    else:
        lines.append("  return nullptr;")
    lines.append("}")
    lines.append("")

    lines.append("const EmbeddedRomEntry *embedded_rom_get(size_t index) {")
    if count:
        lines.append("  if(index >= kEmbeddedRomCount) {")
        lines.append("    return nullptr;")
        lines.append("  }")
        lines.append("  return kEmbeddedRoms[index];")
    else:
        lines.append("  (void)index;")
        lines.append("  return nullptr;")
    lines.append("}")
    lines.append("")

    lines.append("const EmbeddedRomEntry *embedded_rom_find(const char *id) {")
    lines.append("  if(id == nullptr) {")
    lines.append("    return nullptr;")
    lines.append("  }")
    if count:
        lines.append("  for(size_t i = 0; i < kEmbeddedRomCount; ++i) {")
        lines.append("    const EmbeddedRomEntry *entry = kEmbeddedRoms[i];")
        lines.append("    if(entry != nullptr && entry->id != nullptr && strcmp(entry->id, id) == 0) {")
        lines.append("      return entry;")
        lines.append("    }")
        lines.append("  }")
    lines.append("  return nullptr;")
    lines.append("}")
    lines.append("")

    OUTPUT_CPP.write_text("\n".join(lines) + "\n", encoding="utf-8")

    config_lines = [
        "#pragma once",
        "",
        "#define EMBEDDED_ROM_MULTI_SUPPORT 1",
    ]
    (REPO_ROOT / "embedded_rom_config.h").write_text("\n".join(config_lines) + "\n", encoding="utf-8")


def _list(entries: list[dict]) -> None:
    if not entries:
        print("No embedded ROMs registered.")
        return

    print(f"Embedded ROMs ({len(entries)} registered):")
    for entry in entries:
        rom_path = DATA_DIR / entry["file"]
        size = rom_path.stat().st_size if rom_path.exists() else 0
        prefix = "*" if entry.get("autoboot") else "-"
        print(f"  {prefix} {entry['id']:<20} {entry.get('name') or entry['id']} ({size} bytes)")


def _cmd_add(args: argparse.Namespace) -> None:
    entries = _load_manifest()
    rom_path = args.rom.expanduser().resolve()
    if not rom_path.exists():
        raise SystemExit(f"ROM file not found: {rom_path}")
    data = rom_path.read_bytes()
    if not data:
        raise SystemExit("ROM file is empty")

    label = args.name or rom_path.stem
    raw_slug = args.id or _slugify(label)
    slug = raw_slug
    existing = next((entry for entry in entries if entry["id"] == slug), None)
    if existing is not None and not args.force:
        raise SystemExit(f"An embedded ROM with id '{slug}' already exists (use --force to replace)")
    if existing is None:
        slug = _ensure_unique_slug(entries, raw_slug)

    dest_name = f"{slug}{rom_path.suffix.lower() or '.gb'}"
    dest_path = DATA_DIR / dest_name
    _copy_rom(rom_path, dest_path)

    if existing is None:
        new_autoboot = bool(args.autoboot)
        if new_autoboot:
            for e in entries:
                e["autoboot"] = False
        entry = {"id": slug, "name": label, "file": dest_name, "autoboot": new_autoboot}
        entries.append(entry)
    else:
        existing.update({
            "name": label,
            "file": dest_name,
        })
        if args.autoboot is True:
            for e in entries:
                e["autoboot"] = False
            existing["autoboot"] = True

    _save_manifest(entries)
    _generate_cpp(entries)
    print(f"Embedded ROM '{slug}' added ({len(data)} bytes)")


def _cmd_remove(args: argparse.Namespace) -> None:
    entries = _load_manifest()
    slug = args.id
    entry = next((e for e in entries if e["id"] == slug), None)
    if entry is None:
        raise SystemExit(f"No embedded ROM with id '{slug}'")

    rom_path = DATA_DIR / entry["file"]
    if rom_path.exists():
        rom_path.unlink()

    entries = [e for e in entries if e["id"] != slug]
    _save_manifest(entries)
    _generate_cpp(entries)
    print(f"Embedded ROM '{slug}' removed")


def _cmd_list(_: argparse.Namespace) -> None:
    entries = _load_manifest()
    _list(entries)


def _cmd_autoboot(args: argparse.Namespace) -> None:
    entries = _load_manifest()
    if not entries:
        raise SystemExit("No embedded ROMs are registered")

    if args.clear:
        for entry in entries:
            entry["autoboot"] = False
        print("Cleared autoboot flag")
    else:
        slug = args.id
        entry = next((e for e in entries if e["id"] == slug), None)
        if entry is None:
            raise SystemExit(f"No embedded ROM with id '{slug}'")
        for e in entries:
            e["autoboot"] = False
        entry["autoboot"] = True
        print(f"Embedded ROM '{slug}' now set to autoboot")

    _save_manifest(entries)
    _generate_cpp(entries)


def _cmd_generate(_: argparse.Namespace) -> None:
    entries = _load_manifest()
    _generate_cpp(entries)
    print(f"Regenerated {OUTPUT_CPP.relative_to(REPO_ROOT)} from manifest ({len(entries)} entries)")


def _cmd_clear(_: argparse.Namespace) -> None:
    entries = _load_manifest()
    if not entries:
        print("Manifest already empty")
        return
    for entry in entries:
        rom_path = DATA_DIR / entry["file"]
        if rom_path.exists():
            rom_path.unlink()
    if DATA_DIR.exists() and not any(DATA_DIR.iterdir()):
        DATA_DIR.rmdir()
    _save_manifest([])
    _generate_cpp([])
    print("Cleared all embedded ROM entries")


def _build_parser() -> argparse.ArgumentParser:
    parser = argparse.ArgumentParser(description="Manage firmware-embedded Game Boy ROMs")
    sub = parser.add_subparsers(dest="command")

    add_p = sub.add_parser("add", help="Add or replace an embedded ROM entry")
    add_p.add_argument("rom", type=Path, help="Path to the .gb/.gbc file to ingest")
    add_p.add_argument("--name", type=str, help="Friendly display name")
    add_p.add_argument("--id", type=str, help="Slug identifier (auto-derived if omitted)")
    add_p.add_argument(
        "--autoboot",
        action="store_const",
        const=True,
        default=None,
        help="Mark the ROM for autoboot on startup",
    )
    add_p.add_argument("--force", action="store_true", help="Overwrite an existing entry with the same id")
    add_p.set_defaults(func=_cmd_add)

    remove_p = sub.add_parser("remove", help="Remove an embedded ROM entry")
    remove_p.add_argument("id", type=str, help="Identifier of the ROM to remove")
    remove_p.set_defaults(func=_cmd_remove)

    list_p = sub.add_parser("list", help="List all embedded ROM entries")
    list_p.set_defaults(func=_cmd_list)

    autoboot_p = sub.add_parser("autoboot", help="Adjust which ROM autoboots on startup")
    autoboot_group = autoboot_p.add_mutually_exclusive_group(required=True)
    autoboot_group.add_argument("--id", type=str, help="Identifier of the ROM to autoboot")
    autoboot_group.add_argument("--clear", action="store_true", help="Clear any autoboot assignment")
    autoboot_p.set_defaults(func=_cmd_autoboot)

    gen_p = sub.add_parser("generate", help="Regenerate embedded_rom.cpp from the manifest")
    gen_p.set_defaults(func=_cmd_generate)

    clear_p = sub.add_parser("clear", help="Remove all embedded ROMs and reset the manifest")
    clear_p.set_defaults(func=_cmd_clear)

    return parser


def main(argv: list[str] | None = None) -> None:
    parser = _build_parser()
    args = parser.parse_args(argv)
    if not hasattr(args, "func"):
        parser.print_help()
        return

    try:
        args.func(args)
    except Exception as exc:  # noqa: BLE001
        raise SystemExit(str(exc)) from exc


if __name__ == "__main__":
    main(sys.argv[1:])
